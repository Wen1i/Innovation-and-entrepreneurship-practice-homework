# MPT树

MPT（Merkle Patricia Trie）树，即默克尔前缀树，是默克尔树和前缀树的结合。
## MPT结构

### MPT树的节点有以下4种类型：

* 扩展节点（Extension Node）：只能有一个子节点。
* 分支节点（Branch Node）：可以有多个节点。
* 叶子节点（Leaf Node）：没有子节点。
* 空节点：空字符串。
叶子节点和扩展节点
~~~
type shortNode struct {
        Key   []byte
        Val   node
        flags nodeFlag
}
~~~
Key：用来存储属于该节点范围的key；<br>
Val：用来存储该节点的内容；<br>

分支节点
~~~
type fullNode struct {
        Children [17]node // Actual trie node data to encode/decode (needs custom encoder)
        flags    nodeFlag
}
// nodeFlag contains caching-related metadata about a node.
type nodeFlag struct {
    hash  hashNode // cached hash of the node (may be nil)
    gen   uint16   // cache generation counter
    dirty bool     // whether the node has changes that must be written to the database
}
~~~
### key值编码
三种编码方式分别为：

* Raw编码（原生的字符）
Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。
> 例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是[‘c’, ‘a’,
‘t’]，换成ASCII表示方式就是[63, 61, 74]

* Hex编码（扩展的16进制编码）
将原key的高低四位分拆成两个字节进行存储

从Raw编码向Hex编码的转换规则是：

* 将Raw编码的每个字符，根据高4位低4位拆成两个字节；

* 若该Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为终止标志符；

* 若该key对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；
> key为“cat”, value为“dog”的数据项，其Hex编码为[3, 15, 3, 13, 4, 10, 16]
* Hex-Prefix编码（16进制前缀编码）
HP编码的规则如下：

* 若原key的末尾字节的值为16（即该节点是叶子节点），去掉该字节；
* 在key之前增加一个半字节，其中最低位用来编码原本key长度的奇偶信息，key长度为奇数，则该位为1；低2位中编码一个特殊的终止标记符，若该节点为叶子节点，则该位为1；
* 若原本key的长度为奇数，则在key之前再增加一个值为0x0的半字节；
* 将原本key的内容作压缩，即将两个字符以高4位低4位进行划分，存储在一个字节中（Hex扩展的逆过程）
> 若Hex编码为[3, 15, 3, 13, 4, 10, 16]，则HP编码的值为[32, 63, 61, 74]
以上三种编码方式的转换关系为：

Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；

Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；

HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；

## MPT基本操作
### Get
将需要查找Key的Raw编码转换成Hex编码，得到的内容称之为搜索路径；

从根节点开始搜寻与搜索路径内容一致的路径

1. 若当前节点为叶子节点，存储的内容是数据项的内容，且搜索路径的内容与叶子节点的key一致，则表示找到该节点；反之则表示该节点在树中不存在。

2. 若当前节点为扩展节点，且存储的内容是哈希索引，则利用哈希索引从数据库中加载该节点，再将搜索路径作为参数，对新解析出来的节点递归地调用查找函数。

3. 若当前节点为扩展节点，存储的内容是另外一个节点的引用，且当前节点的key是搜索路径的前缀，则将搜索路径减去当前节点的key，将剩余的搜索路径作为参数，对其子节点递归地调用查找函数；若当前节点的key不是搜索路径的前缀，表示该节点在树中不存在。

4. 若当前节点为分支节点，若搜索路径为空，则返回分支节点的存储内容；反之利用搜索路径的第一个字节选择分支节点的孩子节点，将剩余的搜索路径作为参数递归地调用查找函数。
### Insert
插入操作也是基于查找过程完成的，一个插入过程为：

首先找到与新插入节点拥有最长相同路径前缀的节点，记为Node；

若该Node为分支节点：

（1）剩余的搜索路径不为空，则将新节点作为一个叶子节点插入到对应的孩子列表中；

（2）剩余的搜索路径为空（完全匹配），则将新节点的内容存储在分支节点的第17个孩子节点项中（Value）；

若该节点为叶子／扩展节点：

（1）剩余的搜索路径与当前节点的key一致，则把当前节点Val更新即可；

（2）剩余的搜索路径与当前节点的key不完全一致，则将叶子／扩展节点的孩子节点替换成分支节点，将新节点与当前节点key的共同前缀作为当前节点的key，将新节点与当前节点的孩子节点作为两个孩子插入到分支节点的孩子列表中，同时当前节点转换成了一个扩展节点（若新节点与当前节点没有共同前缀，则直接用生成的分支节点替换当前节点）；
若插入成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；

### Delete
找到与需要插入的节点拥有最长相同路径前缀的节点，记为Node；

若Node为叶子／扩展节点：

（1）若剩余的搜索路径与node的Key完全一致，则将整个node删除；<br>
（2）若剩余的搜索路径与node的key不匹配，则表示需要删除的节点不存于树中，删除失败；<br>
（3）若node的key是剩余搜索路径的前缀，则对该节点的Val做递归的删除调用；<br>

若Node为分支节点：

（1） 删除孩子列表中相应下标标志的节点；<br><br>
（2） 删除结束，若Node的孩子个数只剩下一个，那么将分支节点替换成一个叶子／扩展节点；<br>

若删除成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；<br>

## MPT的主要特点

MPT的主要特点就是能够实现快速状态回滚。<br>
区块链公链的环境下，可能会造成分叉而导致区块链状态需要进行回滚的。在以太坊中，由于出块时间短，这种分叉的几率很大，区块链状态回滚的现象很频繁。<br>
所谓的状态回滚指的是：<br>（1）区块链内容发生了重组织，链头发生切换<br>（2）区块链的世界状态（账户信息）需要进行回滚，即对之前的操作进行撤销。<br>
MPT树就提供了一种机制，当区块发生了碰撞，零延迟地完成世界状态的回滚。这种优势的代价就是需要浪费存储空间去冗余地存储每个节点的历史状态。（虽然每生成一个新的区块就会有一棵状态树，但它与前一区块的大部分节点是共享的）<br>
每个节点在数据库中的存储都是值驱动的。当一个节点的内容发生了变化，其哈希相应改变，而MPT将哈希作为数据库中的索引，也就实现了对于每一个值，在数据库中都有一条确定的记录。而MPT是根据节点哈希来关联父子节点的，因此每当一个节点的内容发生变化，最终对于父节点来说，改变的只是一个哈希索引值；父节点的内容也由此改变，产生了一个新的父节点，递归地将这种影响传递到根节点。最终，一次改变对应创建了一条从被改节点到根节点的新路径，而旧节点依然可以根据旧根节点通过旧路径访问得到。






