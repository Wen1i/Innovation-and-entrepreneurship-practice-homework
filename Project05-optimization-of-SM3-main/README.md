# optimization-of-SM3
SM3密码杂凑算法的软件快速实现,根据算法本身的特点,尤其是压缩函数的特点,给出一种更加适用于软件的快速实现方式。实验表明利用此方法可以将算法的效率提升60%左右。

从理论上讲，SM3算法中使用最多且最耗时的是64轮压缩函数和消息扩展,其耗时分别占总耗时的65.9%和24.3%。因此，快速实现的关键在怎样快速实现压缩函数和消息扩展。<br>
### 1. 消息扩展的快速实现
消息扩展的目的是利用512比特的消息分组B扩展得到68个字W0,…,W67和64个字W′0,…,W′63。

快速实现时，为了尽可能减少不必要的数据加载和存储，W0,…,W67和W′0,…,W′63的计算可以调整到压缩函数里执行，具体实施过程是：

1)首先在执行64轮压缩函数前只计算初始的4个字W0,…,W3；

2)然后在压缩函数的第i轮生成Wi+4，而W′i则使用W′i=Wi⊕Wi+4代替。

经过这样的调整，去掉了字W′0,…,W′63，减少了字W0,…,W67和W′0,…,W′63的加载和存储次数，提高了消息扩展的速度。
### 2. 压缩函数的快速实现
压缩函数的快速实现可以从结构调整、流程变更、常数计算等方面着手。

1)压缩函数的结构可以做适当的调整。压缩函数每一轮的最末会执行如下所示的循环右移，A‖B‖C‖D←(A‖B‖C‖D)>>>32,E‖F‖G‖H←(E‖F‖G‖H)>>>32。为了减少循环移位导致的不必要的赋值运算，可以将字的循环右移变更每轮输入字顺序的变动，且这个顺序变动会在4轮后还原，具体情况如下(以下用OneRound(·)表示一轮压缩)：

OneRound(i+0,A,B,C,D,E,F,G,H,W)

OneRound(i+1,D,A,B,C,H,E,F,G,W)

OneRound(i+2,C,D,A,B,G,H,E,F,W)

OneRound(i+3,B,C,D,A,F,G,H,E,W)

2)可以优化压缩函数的中间变量的生成流程。此优化生成流程可以去除不必要的赋值，减少中间变量个数。

3)利用上述调整以及消息扩展部分的调整可以将原来计算TT1、TT2、D和H的过程进行如下的进一步简化。

4)预先计算并存储常数ti=Ti<<<i。这可以避免每个消息分组都去计算常数，且占用的存储空间也很少，仅256 Byte。

优化后的算法将消息扩展和压缩函数结合在一起。下面先描述调整后的消息处理算法，该算法完成消息扩展和64轮压缩迭代；再描述调整后的一轮算法，该算法完成一轮压缩迭代，包括计算必需的消息扩展字Wi+4。

## 对比测试
1)第1组测试中测试1个数据包，该数据包为256×106个字节，此测试用以模拟大量数据杂凑的情况，如大型文件杂凑；

2)第2组测试中杂凑200个数据包，每个数据包1.28×106个字节，此测试用以模拟中型数据包杂凑的情况，如图片等；

3)第3组测试中杂凑40000个数据包，每个数据包6.4×103个字节，此测试用以模拟普通网络数据包杂凑的情况；

4)第4组测试中杂凑8×106个数据包，每个数据包32个字节，此测试用以模拟频繁的微小型数据包杂凑的情况。

为了统计每种测试的准确耗时值，每组测试都反复进行21次并记录各次的时间，最后从大到小排列后取最中间的值作为统计耗时值。
![image](https://user-images.githubusercontent.com/104118101/178648726-83dd0be1-aa99-418b-aed1-d31d4ac19c3c.png)

上表列出的测试结果表明：1)数据包越大，执行效率越高，这是因为大型数据包减少了一头一尾的初始化、消息填充和反初始化等工作：2)优化调整后的算法效率提升显著，可以提升60%左右，在杂凑大中型数据包时速度提升60%以上，即使在杂凑微小型数据包时效率也能提升50%以上。

## 参考文献
[1]杨先伟, & 康红娟. Sm3杂凑算法的软件快速实现研究. 智能系统学报.
